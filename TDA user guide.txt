___Global variables___
The TDA module uses the following global variables in calculation. These variables are accessible to the user and can be modified like
normal variables, but do so with caution.

Simplicial_data = [[a1,a2,...an],[b1,b2...bm],...[x1,x2...xk]] an ordered list of lists where the nth element is a list of n-dimensional simplices
in lexicographical ordering

Simp_li == [[a1,a2,...an],[b1,b2...bm],...[x1,x2...xk]] similar to Simplicial_data, except all simplices in simp_li are linearly independent. Note
that Simplicial_data is this list with all decompositions of the simplices added. It is ordered the same as Simplicial_data

matrix = [m0,m1,...mn] mi is the matrix relating i-dimensional chains to their i-1-dimensional boundaries.

gen_data = [[x1,n1],[x2,n2]...[xm,nm]] where [xi,ni] represents xi of n-1-dimensional simplices

rel_matrix = [[s1,s2...sn],[r1,r2...rm]...[z1,z2...zp]] a list where every element is a list or related simplices of the same dimension.


___Quick Start Guide___

Simplicial data can be modeled by sets of linearly independent simplicies as well as their decompositions (all lower order faces). 
The TDA library can use these generators to compose the simplicial data set for the user in the following way. A set of generators is a two 
tiered list that dictates the number of vertices that describe the simplices (for dimension n, this number is n+1), as well as the number of 
n-dimensional simplices. For example, a set of linearly independent simplicies with two 1-chains, and three 5-chains is represented as 
$[[2,2],[3,6]]$. To pass this data to the TDA package for calculation, one can use the function 'set_gen_data()' in the TDA module, as in the
following example.

>>>s = [[2,2],[3,6]]
>>>TDA.set_gen_data(s)

This function updates the global variables TDA uses in its calculation such as gen_data, simplicial_data, simp_li (the linearly independent
set of simplices, without decompositions). It also initiates the global relation matrix to an identity matrix, and computes the boundary
matrices for the data set. These variables can be accessed and used directly. For example to print the current gen_data as well as the
set simp_li from our above example, one can do the following to get the following outputs:

>>>print(TDA.gen_data)
[[2,2],[3,6]]
>>>print(TDA.simp_li)
[[],[[0,1],[2,3]],[],[],[],[[4,5,6,7,8,9],[10,11,12,13,14,15],[16,17,18,19,20,21]]

Next, relation data can be passed to TDA through similar methods. First, a relation list should be constructed as a list that contains sublists of
related simplices. Simplices within sublists must be of the same dimension. For example, the list r = [[[0,1],[3,5]],[[2],[4]]] relates the face 
[0,1] to [3,5] and the vertex 2 to vertex 4. To pass these relations to TDA, one can either update the relation set directly, or use the function
set_rel_set().

>>>r = [[[0,1],[2,3]]]
>>>TDA.rel_set = r
or
>>>TDA.set_rel_set(r)

With relation data in place the user can now use the delta functions to produce the boundaries of a delta complex. There are two methods for calculating
the boundaries of the complex. The first is delta_m(state), which uses a method of matrix multiplication against the relation matrix to obtain the 
boundaries, and requires a string argument 'state'. This variable determines which style of relation matrix is used in calculation, where 'eq' uses a 
totally equivalent matrix, 'ns' uses a non symmetric and semi transitive equivalence matrix, and 'nst' uses a neither symmetric nor transitive matrix.
The second method of obtaining the boundary is called delta_rowaddition(), which combines information from related rows repeatedly to obtain the boundary
data. Both methods are used similarly, and will return a list of matrices representing the boundary data. This list of matrices is still of the same size as
the original boundary matrix, and does not have 'dead chains' removed (i.e. chains that have been related to other chains, who's boundary information is no 
longer necessary). The following is an example of how to use delta_m with our running example.

>>>d = TDA.delta_m('eq')

The variable d is now the updated boundary matrix. Setting the result of the delta function as a variable like above will not print anything on completion.
However, be aware that if the function is simply run, the entire matrix list by default will be printed when the matrix list is returned, and these matrices
can easily become quite large. In the following example we use a smaller generating set to illustrate the output.

>>>h = [[2,2]]
>>>TDA.set_gen_data(h)
>>>rr = [[[0],[2]]]
>>>TDA.set_rel_set(rr)
>>>TDA.delta_m('eq')
[Matrix([
[-1,-1],
[ 1, 0],
[-1,-1],
[ 0, 1]])]

To remove the dead boundaries from the matrix list, the function killdeadboundaries(d) can be used, where d is the updated boundary matrix. A list of 
surviving simplices (i.e. simplices that are lowest order relations of the data set) can be obtained with the function killdeadchains(). In the above
example with generator set h, the list of living chains would be [[[0],[1],[3]],[[0,1],[2,3]]]


___Additional Functions___

There are additional functions in TDA that the user may find useful in calculation. Many of these are within the Delta.py module that TDA uses for its 
own calculations. With any such function, say f(), instead of calling TDA.f(), one calls TDA.Delta.f(). These functions will be labeled below as Delta
functions if that's where they reside.

Delta: decomp(s,p) --> recursively decomposes a simplex s into an unsorted list of its faces. The p parameter is used in the recursive calculation and should
be set to 0 if a full decomposition is desired.
Example: 
>>>s = [0,1,2]
>>>TDA.Delta.decomp(s,0)
[[0,1],[0],[1],[0,2],[2],[1,2]]

Delta: getsimplicialdata_basic(g) --> Takes a list of generators (such as gen_data) and produces a linearly independent ordered set of simplices. This is 
essentially the function that produces the global variabe simp_li described above.
Example:
>>>g = [[2,2]]
>>>TDA.Delta.getsimplicialdata_basic(g)
[[],[[0,1],[2,3]]]

Delta: getsimplicialdata(g) --> Takes a list of generators and returns the whole ordered simplicial set. This is the function that produces simplicial_data
described above.
Example:
>>>g = [[2,2]]
>>>TDA.Delta.getsimplicialdata_basic(g)
[[[0],[1],[2],[3]],[[0,1],[2,3]]]

TDA: quicksort(a) --> Takes a list of unsorted simplices of the same dimension, and sorts them by lexicographical ordering using a quicksort algorithm.
is called by TDA.quicksort(a) and is not identical to the normal quicksort algorithm.

TDA: findsimp(s,dim) --> Takes a simplicie s, and its dimension (which in most cases can be called as len(s)-1), and returns the position of s within
simplicial_data[dim], thus giving the relative order of s among all dim simplices. 

TDA: findrel(s) --> Takes a simplicie s and returns its lowest order relation so far. If s is not related to anything then findrel(s) = s.

TDA: compute_lower_rel(r) --> Takes a list of related simplices, and returns a list of simplices of 1 dimension less that are now related as a result.
This r is not stuctured the same as the global rel_set, but is more akin to an element of rel_set
Example:
>>>r = [[0,1],[2,3]]
>>>compute_lower_rel(r)
[[[0],[2]],[[1],[3]]] 

TDA: startDelta() --> This function is an alternative to starting the computation of the delta boundaries. It will prompt the user for the style of 
calculation (either 'm' for multiplication or 'r' for row addition), as well as the style of relation matrix used (same as input for delta_m, see above).
After the calculation is completed, it will then print out the final boundary matrix, relation matrix, and the list of living chains.

TDA: set_simplicial_data(s) --> The user can use this function to set the variable simplicial_data equal to the parameter s. It will automatically update
the relation matrix as well as the unrelated boundaries. Be cautious if using this, because neither gen_data or simp_li are updated, and may then contain 
inconsistent data.

